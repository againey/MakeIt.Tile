<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>Tile-Based Worlds - Manual - by Experilous</title>
		<style type="text/css">
			<!--/*--><![CDATA[/*><!--*/
			html
			{
				margin: 0;
				padding: 0;
			}
			
			body
			{
				margin: 0 auto;
				padding: 36pt 72pt;
				max-width: 540pt;
			}
			
			section
			{
				margin: 0;
				padding: 0;
			}
			
			h1
			{
				margin: 0;
				padding: 0;
				font-size: 200%;
			}
			
			h2
			{
				font-size: 175%;
			}
			
			h3
			{
				font-size: 150%;
			}
			
			h4
			{
				font-size: 125%;
			}
			
			h1 div.title
			{
				font-size: 100%;
			}
			
			h1 div.subtitle
			{
				font-size: 75%;
			}
			
			section.chapter:first-of-type
			{
				counter-reset: section;
			}
			
			section.chapter
			{
				counter-increment: section;
			}
			
			section.chapter section:first-of-type
			{
				counter-reset: section;
			}

			section.chapter section
			{
				counter-increment: section;
			}
			
			*.section-head:before
			{
				content: counters(section, ".") ". ";
			}
			
			dt
			{
				display: list-item;
				list-style-type: disc;
				margin-left: 1em;
				font-weight: bold;
				font-style: italic;
			}
			/*]]>*/-->
		</style>
	</head>
	<body>
		<section id="introduction">
			<h1>
				<div class="title">Tile-Based Worlds, by <a href="http://experilous.com" target="experilous">Experilous</a></div>
				<div class="subtitle">User's Manual</div>
			</h1>
			<p>Tile-Based Worlds is a framework for Unity to aid in the creation and usage of game worlds which are divided up into discrete tiles.
				It is designed to be maximally flexible, applying just as easily to the simple 8x8 game world of chess as to a large hex grid in a strategy game or even an irregular arrangement of tiles on the surface of a sphere.</p>
			<p>Although the framework does contain some high-level tools such as for generating ready-to-use meshes and prefabs, and for detecting and handling tile-based mouse clicks,
				it is not designed as a top-to-bottom solution, but is rather intended to be a foundation upon which many different game mechanics can be easily built.
				Additional scripting will therefore be necessary in almost all cases.<p>
		</section>
		
		<section id="contents">
			<h2>Contents</h2>
			<ol>
				<li><a href="#quick-start">Quick Start</a></li>
					<ol>
						<li><a href="#examples">Example Scenes &amp; Content</a></li>
						<li><a href="#create-your-own">Creating Your Own Content</a></li>
					</ol>
				<li><a href="#topologies">Topologies, the Core Data Structure</a></li>
				<li><a href="#attributes">Element Attributes</a></li>
				<li><a href="#edge-wrapping">Edge Wrapping</a></li>
				<li><a href="#surface-types">Surface &amp; Topology Types</a>
					<ol>
						<li><a href="#spherical-surfaces">Spherical Surfaces</a></li>
						<li><a href="#planar-surfaces">Planar Surfaces</a>
							<ol>
								<li><a href="#quad-grid-tiles">Quad Grid Tiles</a></li>
								<li><a href="#hex-grid-tiles">Hex Grid Tiles</a></li>
							</ol>
						</li>
					</ol>
				</li>
				<li><a href="#additional">Additional Utilities</a></li>
					<ol>
						<li><a href="#dynamic-mesh">Dynamic Mesh</a></li>
						<li><a href="#randomization">Topology Randomization</a></li>
						<li><a href="#spatial-partitioning">Spatial Partitioning</a></li>
						<li><a href="#topology-traversal">Topology Traversal</a>
							<ol>
								<li><a href="#path-finding">Path Finding</a></li>
								<li><a href="#distance-ordered-visitation">Distance Ordered Visitation</a></li>
								<li><a href="#random-visitation">Random Visitation</a></li>
							</ol>
						</li>
					</ol>
				</li>
				<li><a href="#generation">In-Editor Generation</a></li>
				<li><a href="#wrap-around">Integration with Wrap-Around Worlds</a></li>
			</ol>
		</section>
		
		<section class="chapter" id="quick-start">
			<h2 class="section-head">Quick Start</h2>
			<section id="examples">
				<h2 class="section-head">Example Scenes &amp; Content</h2>
				<p>Included in this package are example scenes and pre-generated content to demonstrate some of the worlds that the framework can create and manage.
					These scenes can be found in the <a href="Experilous/Examples/Tile-Based Worlds/">&lt;project&gt;/Assets/Experilous/Examples/Tile-Based Worlds/</a> folder.
					The planar scenes each contain one planar topology, and can be controlled with standard arrow/WASD controls with mouse look; mouse wheel will adjust elevation.
					The spherical scene is similar, but without mouse look; instead, it uses a camera controller that locks the view onto the sphere.</p>
				<dl>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Buried Bomb Hunter.unity">Buried Bomb Hunter</a></dt>
					<dd>A clone of Minesweeper, supporting square, hexagonal, and jumbled cells.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Spherical Path Finding Demo.unity">Spherical Path Finding Demo</a></dt>
					<dd>A generated tile-based planet with four different terrain types, unit path finding, and fog-of-war.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Texture Demo.unity">Texture Demo</a></dt>
					<dd>A demonstration of different techniques for generating UV mappings to apply textures to topology-based meshes.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Planar Topologies.unity">Planar Topologies</a></dt>
					<dd>A few pre-generated planar surfaces with various tile shapes.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Spherical Topology.unity">Spherical Topology.unity</a></dt>
					<dd>A pre-generated spherical surface with randomly shaped tiles which mostly began as hexagonal tiles before being randomized.</dd>
				</dl>
				<p>If you also have access to the Wrap-Around Worlds framework and import
					<a href="Experilous/Packages/Tile-Based Wrap-Around Integration - With Examples.unitypackage">Tile-Based Wrap-Around Integration - With Examples&#8203;.unitypackage</a>,
					then you will gain access to a few more example scenes.</p>
				<dl>
					<dt><a href="Experilous/Examples/Tile-Based Wrap-Around Worlds/Planar Hex Grid Horizontal Wrap.unity">Planar Hex Grid Horizontal Wrap</a></dt>
					<dd>A pre-generated planar surface with hexagonal tiles arranged at an angle to create a parallelogram-shaped world.  The world wraps around across the left and right edges.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Wrap-Around Worlds/Planar Random Grid Full Wrap.unity">Planar Random Grid Full Wrap</a></dt>
					<dd>A pre-generated planar surface with randomly shaped tiles which began as hexagonal tiles before being randomized.  The world wraps around both across the top and bottom edges and across the left and right edges.</dd>
				</dl>
			</section>
			
			<section id="create-your-own">
				<h2 class="section-head">Creating Your Own Content</h2>
				<p>The content used in the above example scenes can be found in the <a href="Experilous/Examples/Tile-Based Worlds/Data">&lt;project&gt;/Assets/Experilous/Examples/Tile-Based Worlds/Data</a> folder.
					Most of the data is not meant to be edited directly.  However, if you locate and select the asset within each subfolder named "Generator.asset", the inspector will show you the full details for generating the other assets in that subfolder.
					You can freely modify the values within the inspector and click the Generate button, and the associated scene should automatically use the new assets generated, in particular the prefab with all of the generated meshes.</p>
				<p>To create a generator from scratch, use the Create button in the Projects window, or right click in the Projects window content area where you would like to create the generator.
					Navigate in the menu to Topology, and then choose the type of topology you would like to create.  A folder will be created and a generator asset placed within it with some basic settings already configured.
					You should be able to immediately click the Generator button, or you can first adjust values.
					You will likely also want to add additional content generators, which you can do using the Add Generator button at the bottom of the inspector.
					The gear icon at the top right of every content generator provides a menu that will let you reorder or remove items.</p>
				<p>Once you've generated content, you can begin to use it from within your scene.
					Since most of the content is raw data wrapped in scriptable objects, you will be able to use very little of it unless you write your own components that can consume these objects.
					However, the generator is capable of creating prefabs which can easily be dragged into your scene just like any other prefab.</p>
				<p>Note that the prefab generator has a field where you can specify another prefab.
					This configurable prefab will be used by the prefab generator as a base template for any mesh renderers that it creates.
					You will want to assign a prefab that includes a mesh filter and mesh renderer component, with a material specified for the mesh renderer.
					Otherwise, the prefab will be rendered without any material at all, and will obviously not look correct as a result.
					There is a sample material included in the examples folder called "<a href="Experilous/Examples/Shared Resources/Manifold.mat">Manifold.mat</a>",
					and is used by "<a href="Experilous/Examples/Tile-Based Worlds/Resources/Manifold Mesh.prefab">Manifold Mesh.prefab</a>".
					You can assign this prefab to the prefab generator's mesh prefab field to get a quick idea of what the generated topology looks like.</p>
			</section>
		</section>
		
		<section class="chapter" id="topologies">
			<h2 class="section-head">Topologies, the Core Data Structure</h2>
			<p>The core of the Tile-Based Worlds framework is a topology, a data structure for representing the relations between vertices, edges, and faces.
				In terms of the primary use case for this framework, faces are typically synonymous with tiles, while vertices are the corners of each tile.
				Edges are the boundaries between two adjacent faces/tiles, though they can simultaneously be treated as the connections between two adjacent vertices/corners.</p>
			<p>Faces must have at least three neighbors, but have no practical upper bound.  (Technically, a cached neighbor count limits them to a maximum of 65,535 neighbors.)
				Vertices are similar, except that most algorithms permit a vertex with only two neighbors, and some might even be okay with a vertex with only a single neighbor.
				Each face and vertex can have a differing number of neighbors even within the same topology; a topology might consist of a mix of pentagons and hexagons, for example.
				Each edge has exactly two neighbors, one on each side of the edge.  Although technically, each edge is stored as a pair of half-edges, and each half-edge is directed, pointing at only one of the two neighbors.</p>
			<p>The class <code>Experilous.Topological.Topology</code> is responsible for storing all the raw data of the topology data structure.
				It also provides access to the elements of the data structure through nested structs <code>Vertex</code>, <code>Face</code>, <code>HalfEdge</code>, <code>VertexEdge</code>, and <code>FaceEdge</code>.
				The latter three structs all represent exactly the same underlying data, but also express the context within which edges are being used.
				Instances of <code>HalfEdge</code> refer to half-edges directly, while <code>VertexEdge</code> and <code>FaceEdge</code> refer to half-edges within the context of the vertex or face that they point <em>away from</em>.</p>
			<p>The <code>Vertex</code> and <code>Face</code> structs allow enumeration of their neighbors, in the form of <code>IEnumerator&lt;VertexEdge&gt;</code> and <code>IEnumerator&lt;FaceEdge&gt;</code>, respectively.
				These enumerators will visit the half-edges that radiate from the source vertex or border the source face in clockwise order.
				Given that <code>FaceEdge</code> provides <code>farFace</code> and <code>nextVertex</code> properties, and <code>VertexEdge</code> provides <code>farVertex</code> and <code>prevFace</code> properties,
				it is easy to enumerate all the neighboring vertices or faces of any given vertex or face.
				The <code>nearVertex</code> and <code>nearFace</code> properties can be used to get the implicit element whose neighors are being enumerated by a given <code>VertexEdge</code> or <code>FaceEdge</code>.</p>
			<p>The majority of faces in a topology will be ordinary "internal" faces, but depending on the shape of the topology, some faces might be external.
				This means that they're not part of the normal world, but are included in order to simplify the invariants of the data structure.
				In particular, the requirement that every edge has exacty two neighboring faces, and the requirement that the neighboring vertex count, edge count, and face count are all equal for any given vertex or face.
				An example topology would be a chess board, which has sixty-four internal faces, and then one external face which represents everything outside of the chess board.
				Another example would be the world map of the Civilization series of games, in which the north pole region and the south pole region are two distinct external faces.</p>
		</section>
		
		<section class="chapter" id="attributes">
			<h2 class="section-head">Element Attributes</h2>
			<p>The elements of a topology are stored in such a way that they all have contiguous integer indices starting from zero.
				This means that if you want to associate additional data with each element, all you need to do is create an array or list of the appropriate size and desired type,
				and this data can then be easily accessed whenever you want to look up that attribute's value for a given vertex, half-edge, or face.
				The most obvious attribute is probably vertex positions, which can be stored as a container of <code>Vector3</code>.
				Other examples include face normals, face colors, and edge pathfinding costs.</p>
			<p>Given that faces can be either internal or external, it can often be appropriate to store data only for internal faces.
				Therefore, all internal faces come first, starting at index zero, while all external faces are stored at the very end of the contiguous indices.
				For attributes that only make sense for internal faces, simply use the internal face count as the size when creating the container.
				For attributes that apply to all faces whether internal or not, use the total face count as the size.
				For attributes that only apply to external faces, you can create an appropriately sized container, but you'll need to index into it manually, since the indices of external faces don't start at zero.
			<p>The various helper structs discussed above all have an <code>index</code> property that can be used to access an array or list directly.
				Even better, however, is to create a wrapper around the container that implements the <code>IVertexAttribute</code>, <code>IEdgeAttribute</code>, or <code>IFaceAttribute</code> interface.
				This will allow the attributes to be accessed directly by one of the helper structs, without needing to access the <code>index</code> property explicitly.
				Additionally, this can provide further utility by allowing the access of an attribute to be modified based on the context of access.
				This is particularly useful in the case of wrap-around edges discussed below, in which a vertex's effective position is dependent upon which neighbor (face or vertex) defines the current context.</p>
		</section>
		
		<section class="chapter" id="edge-wrapping">
			<h2 class="section-head">Edge Wrapping</h2>
			<p>For a topological world that allows wrapping around along some or all world boundaries, complications can arise when the topology is embedded within standard Euclidean space.
				Consider a flat rectangular world that wraps around along the right and left sides (such as a map from the Civilization series).
				The vertices along the left edge are in fact the same vertices along the right edge, and so each one will only have a single position in space, which I will dub the "canonical" position.
				But when drawing the tiles on the left side of the map versus those on the right, the vertex positions need to be treated differently.
				If the canonical positions are the ones that apply to the left side of the map, then when using those vertex positions along the right side of the map,
				the full width of the world needs to be added to the canonical positions to get the effective positions for rendering the tiles.</p>
			<p>To enable this kind of transformation, one needs to know the context of how an attribute such as position is being accessed.
				This context is defined in terms of which other topology object the attribute is relative to.
				In the above example, vertex positions are being accessed relative to the face that is being rendered, so it is a vertex-to-face relation.
				If we know the wrapping relation between any particular face and a neighboring vertex, then we can decide how to transform the canonical position to get the final position to be used.</p>
			<p>Within the Tile-Based Worlds framework, this relational information is stored within the edge data,
				encoding details about the near vertex and face and far vertex and face all relate to each other and to the edge itself.
				Edges can be used to access vertex and face attributes, and so such attributes can use the relational information to transform the vertex or face attribute value based on wrapping behavior.
				For example, accessing a vertex position using a face edge will enable the attribute container to return the vertex position relative to the near face of the edge used for access.</p>
			<p>Most attributes are oblivious to wrapping, and most attributes would not be able to meaningfully utilize wrapping information anway.
				To take advantage of wrapping behavior, either use the <code>PositionalVertexAttribute</code>, <code>PositionalEdgeAttribute</code>, and <code>PositionalFaceAttribute</code> classes to store your data,
				or create similar classes of your own that make use of an edge's relational information when accessing the attribute using an edge.</p>
		</section>
		
		<section class="chapter" id="surface-types">
			<h2 class="section-head">Surface &amp; Topology Types</h2>
			<p>Surfaces are useful abstractions for describing the overall shape that a topology will represent, without directly storing the all the vertex/edge/face data explicitly.
				They provide a convenient description from which the full topology data can be generated.
				They can also provide additional details beyond the raw topology data that aids other areas of code in performing their functions.</p>
			
			<section id="spherical-surfaces">
				<h3 class="section-head">Spherical Surfaces</h3>
				<p>Spherical surfaces are useful for creating tile-based planets.
					Because of the nature of the sphere, there are very few perfectly regular tilings, so you'll almost inevitably require a mix of vertices and/or faces with differing numbers of neighbors.</p>
				<p>The current methods for generating topologies from spherical surfaces come from the <code>SphericalManifoldUtility</code>,
					and begin with one of the five Platonic solids which can then be further subdivided as desired.
					If you wish to predictability of the occasional vertex or face with a different number of neighbors than most that result from subdividing a Platonic solid,
					see the section on <a href="#randomization">topology randomization</a>.</p>
			</section>
			
			<section id="planar-surfaces">
				<h3 class="section-head">Planar Surfaces</h3>
				<p>Planar surfaces are the most prevalent form of tile-based surfaces.
					While they can be extended to support elevations and therefore do not need to be strictly flat, they still must remain completely mappable to a two-dimensional plane.
					Because of their planar nature, perfectly regular tilings are far more flexible than with spherical surfaces,
					but <a href="#randomization">topology randomization</a> can be applied to either surface type equally.
				
				<section id="quad-grid-tiles">
					<h4 class="section-head">Quad Grid Tiles</h4>
					<p>To aid in creating and using standard grids of squares (or parallelograms in general), you may use the <code>RectangularQuadGrid</code> class.
						It is rectangular in that the overall world it describes has a specified width and height (measured in face counts in each dimension).
						It is a quad grid in that each face has exactly four neighbors (or eight, if you also count the four diagonal faces that only touch at a vertex).
						The faces do not need to be squares, but can be any sort of parallelogram.</p>
					<p>Because <code>RectangularQuadGrid</code> implements the <code>IFaceNeighborIndexer</code> interface,
						it can be used by the <code>TopologyUtility.BuildTopology()</code> function to automatically create the full topology data.
						Alternatively, you can use <code>RectangularQuadGrid.CreateManifold()</code> to not only create the topology data,
						but also provide vertex positions according to the specifications of the surface.</p>
					<p>Also, by implementing the <code>IFaceIndexer2D</code> and <code>IVertexIndexer2D</code> interfaces,
						<code>RectangularQuadGrid</code> can be used to get the two-dimensional integer coordinate of each vertex and face,
						or to perform the inverse operation, find the vertex or face givne a two-dimensional integer coordinate.
						This makes it easy to implement any algorithms that are most naturally expressed using such a two-dimensional coordinate system.</p>
				</section>
				
				<section id="hex-grid-tiles">
					<h4 class="section-head">Hex Grid Tiles</h4>
					<p>To aid in creating and using standard grids of hexagons, you may use the <code>RectangularHexGrid</code> class.
						Like the <code>RectangularQuadGrid</code> class, it is rectangular in that the overall world it describes has a specified width and height (measured in face counts in each dimension).
						It is a quad grid in that each face has exactly four neighbors (or eight, if you also count the four diagonal faces that only touch at a vertex).
						Its faces, however, are all hexagons, as its name implies.</p>
					<p>Constructing a hex grid requires a bit more information than constructing a quad grid.
						There are a few options regarding how to arrange the rows and columns of the grid.
						The primary option is which, if either, of the two axes will have its hexagons staggered back and forth every other row/column.
						If staggered, then you can acquire a roughly rectangular world while still maintaining regular hexagonal faces.
						Otherwise, the hexagonal faces will either need to be distorted, or your overall world shape will instead be a parallelogram, with default interior angles of 60&deg; and 120&deg;.
					<p>Secondary options are whether the angle produced by the three hexagons at the origin is acute or obtuse,
						and whether staggered rows/columns have one fewer face in order to maintain symmetry.</p>
					<p>Because <code>RectangularHexGrid</code> implements the <code>IFaceNeighborIndexer</code> interface,
						it can be used by the <code>TopologyUtility.BuildTopology()</code> function to automatically create the full topology data.
						Alternatively, you can use <code>RectangularHexGrid.CreateManifold()</code> to not only create the topology data,
						but also provide vertex positions according to the specifications of the surface.</p>
					<p>Also, by implementing the <code>IFaceIndexer2D</code> and <code>IVertexIndexer2D</code> interfaces,
						<code>RectangularHexGrid</code> can be used to get the two-dimensional integer coordinate of each vertex and face,
						or to perform the inverse operation, find the vertex or face givne a two-dimensional integer coordinate.
						This makes it easy to implement any algorithms that are most naturally expressed using such a two-dimensional coordinate system.
						Note that because hex grids are more complex than square grids, the exact behavior of the two-dimensional coordinates depends on how the grid was constructed.
						Alternative implementations of <code>IFaceIndexer2D</code> and <code>IVertexIndexer2D</code> can be written to provide alternate indexing schemes if desired.</p>
				</section>
			</section>
		</section>
		
		<section class="chapter" id="additional">
			<h2 class="section-head">Additional Utilities</h2>
			<section id="dynamic-mesh">
				<h3 class="section-head">Dynamic Mesh</h3>
			</section>
			
			<section id="randomization">
				<h3 class="section-head">Topology Randomization</h3>
				<p>The <code>TopologyRandomizer</code> class can be used to jumble a topology to be less regular.
					It achieves this by altering a random subset of edges, shifting the edges to different pairs of nearby vertices or faces than they had been relating originally.</p>
				<p>It performs this process in one or more passes.  After each pass through all edges, some relaxation and repair passes are performed to fix up any positional anomalies produced in the main pass.
					These anomalies are due to the fact that the main pass alters the topological relations only, and does not adjust vertex positions or any other attributes at all.
					Faces are likely to become concave or even inside out during the main pass.</p>
				<p>The relaxation passes attempt to gently nudge vertex positions around in order to conform to certain constraints.
					The two constraints currently implemented aim for regularity and equal per-face area, respectively.
					Regularity refers to polygon regularity.  This constraint prefers that all edge lengths be equal,
					but it strongly biases faces with more neighbors to be significantly larger than faces with fewer neighbors.
					The equal area constraint on the other hand prefers all faces to have roughly equal area,
					but it tends to produce irregular polygon faces and edges of varying lengths.
					There are examples of blending these two contraints together using any proportion desired.</p>
				<p>The repair pass is more of a blunt process to correct for any egregious errors produced in the main pass and not fixed by relaxation,
					as well as such errors that are actually produced by the relaxation pass.
					These are errors of concavity or more serious flaw in the shape of a face.</p>
			</section>
			
			<section id="spatial-partitioning">
				<h3 class="section-head">Spatial Partitioning</h3>
				<p>Spatial partitioning is a means of dividing up space in such a way that certain types of spatial lookups can be performed efficiently.
					For topologies, a common operation is to determine which face a particular ray intersects, if any.
					Implementations of the <code>IFaceSpatialPartitioning</code> interface provide this functionality.</p>
				<p>This framework comes with the <code>UniversalFaceSpatialPartioning</code> class, a universal implementation that works with any topology.
					Whether you are working with a sphere or a plane, with square grids, hexagonal grids, or randomized tiles,
					this class will be able to tell you which face any specified ray intersects.
					It will even work with wrap-around worlds, when the ray is aimed at a region outside of the canonical world bounds.</p>
				<p>If you have a highly regular grid and need to perform a large number of ray intersections,
					it may be preferable to implement a more intelligent and efficient intersection test using knowledge of the grids irregularity.</p>
			</section>
			
			<section id="topology-traversal">
				<h3 class="section-head">Topology Traversal</h3>
				<section id="path-finding">
					<h4 class="section-head">Path Finding</h4>
					<p>Depending on your usage of topologies generated by this framework,
						it is likely that at some point you'll need to find paths from one face to another.
						The <code>PathFinder</code> class enables you to find such paths flexibly and efficiently, using the A* algorithm.</p>
					<p>The heuristic cost function and actual cost can both be defined according to your particular pathfinding needs,
						and defaults are provided for using standard Euclidean distance or spherical distance derived from face positions.</p>
					<p>Instances of <code>PathFinder</code> as well as instances of the path classes it returns are fully reusable,
						which can cut down on the amount of memory management that the runtime needs to perform.
						Nonetheless, multiple independent instances of <code>PathFinder</code> can also be created,
						allowing fully concurrent processing on multiple threads without conflict.</p>
				</section>
				
				<section id="distance-ordered-visitation">
					<h4 class="section-head">Distance Ordered Visitation</h4>
					<p>If you wish to enumerate nearby faces starting from a single initial face, and proceeding through the faces according to their distance from the initial face,
						you can make use of the depth and distance based functions in the <code>FaceVisitationUtility</code> class.
						Both breadth-first and depth-first traversals are supported, and distance can be measured by whatever means you need for your particular use case.</p>
					<p>Default distance measurements are provided for simple depth (number of faces traversed from the initial face),
						as well as spatial distances based on either Euclidean or spherical metrics.
						Alternatively, an edge attribute can be provided which specifies the accumulable distance of each edge.
						Maximum depth/distance can also be specified to cap the traversal to a local region around the initial face.</p>
					<p>Vertices can be visited in the same way using the <code>VertexVisitationUtility</code> class.</p>
				</section>
				
				<section id="random-visitation">
					<h4 class="section-head">Random Visitation</h4>
					<p>Random visitation is also provided within the <code>VertexVisitationUtility</code> and <code>FaceVisitationUtility</code> classes.
						You specify the root vertices or faces, and the enumerator returned will randomly select unvisited vertices/faces
						that are adjacent to one of the roots or any previously visited vertex/face, until no more adjacent vertices/faces remain.</p>
					</p>This can be particularly convenient for dividing a topology into a fixed number of randomly shaped clusters.</p>
				</section>
			</section>
		</section>

		<section class="chapter" id="generation">
			<h2 class="section-head">In-Editor Generation</h2>
		</section>
		
		<section class="chapter" id="wrap-around">
			<h2 class="section-head">Integration with Wrap-Around Worlds</h2>
			<p>If you also have access to the Wrap-Around Worlds framework and import
				<a href="Experilous/Packages/Tile-Based Wrap-Around Integration - With Examples.unitypackage">Tile-Based Wrap-Around Integration&#8203;.unitypackage</a>,
				then you will obtain some tools that can improve the integration of the functionalities of these two frameworks.</p>
			<p>At present, the only addition is a different world type that frees you from having to manually configure its shape or wrap-around properties.
				Instead, you only need to supply a <code>Surface</code> asset reference, and it will work out the world shape automatically.</p>
			<p>Beyond that, if you are generating meshes and prefabs for your tile-based worlds,
				you will probably want to ensure that the mesh generator uses subdivided chunks of the world to create multiple meshs,
				and that the prefab assigned to the prefab generator includes the relevant element components described above (most likely just the <code>RenderableElement</code> component).
				This will allow the wrapping information contained with the world topology to apply not just when enumerating topology element neighbors,
				but also when rendering the world and applying physics, which is naturally ideal.</p>
		</section>
	</body>
</html>
