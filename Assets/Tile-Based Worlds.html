<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>Tile-Based Worlds - Manual - by Experilous</title>
		<style type="text/css">
			<!--/*--><![CDATA[/*><!--*/
			html
			{
				margin: 0;
				padding: 0;
			}
			
			body
			{
				margin: 0 auto;
				padding: 36pt 72pt;
				max-width: 540pt;
			}
			
			section
			{
				margin: 0;
				padding: 0;
			}
			
			h1
			{
				margin: 0;
				padding: 0;
				font-size: 200%;
			}
			
			h2
			{
				font-size: 175%;
			}
			
			h3
			{
				font-size: 150%;
			}
			
			h4
			{
				font-size: 125%;
			}
			
			h1 div.title
			{
				font-size: 100%;
			}
			
			h1 div.subtitle
			{
				font-size: 75%;
			}
			
			section.chapter:first-of-type
			{
				counter-reset: section;
			}
			
			section.chapter
			{
				counter-increment: section;
			}
			
			section.chapter section:first-of-type
			{
				counter-reset: section;
			}

			section.chapter section
			{
				counter-increment: section;
			}
			
			*.section-head:before
			{
				content: counters(section, ".") ". ";
			}
			
			dt
			{
				display: list-item;
				list-style-type: disc;
				margin-left: 1em;
				font-weight: bold;
				font-style: italic;
			}
			/*]]>*/-->
		</style>
	</head>
	<body>
		<section id="introduction">
			<h1>
				<div class="title">Tile-Based Worlds, by <a href="http://experilous.com" target="experilous">Experilous</a></div>
				<div class="subtitle">User's Manual</div>
			</h1>
			<p>Tile-Based Worlds is a framework for Unity to aid in the creation and usage of game worlds which are divided up into discrete tiles.
				It is designed to be maximally flexible, applying just as easily to the simple 8x8 game world of chess as to a large hex grid in a strategy game or even an irregular arrangement of tiles on the surface of a sphere.
				It includes out-of-the-box support for:</p>
			<ul>
				<li>Square, Hex, and Irregular Grids</li>
				<li>Planar and Spherical Worlds</li>
				<li>World Edge Wrap-Around</li>
				<li>Mouse Picking</li>
				<li>A* Path Finding</li>
				<li>Dynamic Mesh Generation</li>
				<li>Neighboring Tile Visitation</li>
				<li>Randomization Library</li>
			</ul>
			<p>In addition to the above features, the framework is very extensible, to support whatever tiling patterns, tile attributes, and algorithms you might need.</p>
			<p><strong>Scripting Note:</strong> Although the framework does contain some high-level tools usable directly within the editor,
				it is not designed as a top-to-bottom solution, but is rather intended to be a foundation upon which many different game mechanics can be easily built.
				Additional scripting will therefore be necessary in almost all cases.<p>
		</section>
		
		<section id="contents">
			<h2>Contents</h2>
			<ol>
				<li><a href="#quick-start">Quick Start</a></li>
					<ol>
						<li><a href="#examples">Example Scenes &amp; Content</a></li>
						<li><a href="#create-your-own">Creating Your Own Content</a></li>
					</ol>
				<li><a href="#topologies">Topologies, the Core Data Structure</a></li>
				<li><a href="#attributes">Element Attributes</a></li>
				<li><a href="#edge-wrapping">Edge Wrapping</a></li>
				<li><a href="#surface-types">Surface &amp; Topology Types</a>
					<ol>
						<li><a href="#spherical-surfaces">Spherical Surfaces</a></li>
						<li><a href="#planar-surfaces">Planar Surfaces</a>
							<ol>
								<li><a href="#quad-grid-tiles">Quad Grid Tiles</a></li>
								<li><a href="#hex-grid-tiles">Hex Grid Tiles</a></li>
							</ol>
						</li>
					</ol>
				</li>
				<li><a href="#additional">Additional Utilities</a></li>
					<ol>
						<li><a href="#dynamic-mesh">Dynamic Mesh</a></li>
						<li><a href="#randomization">Topology Randomization</a></li>
						<li><a href="#spatial-partitioning">Spatial Partitioning</a></li>
						<li><a href="#topology-traversal">Topology Traversal</a>
							<ol>
								<li><a href="#path-finding">Path Finding</a></li>
								<li><a href="#connected-visitation">Connected Visitation</a></li>
							</ol>
						</li>
					</ol>
				</li>
				<li><a href="#generation">In-Editor Generation</a></li>
			</ol>
		</section>
		
		<section class="chapter" id="quick-start">
			<h2 class="section-head">Quick Start</h2>
			<section id="examples">
				<h2 class="section-head">Example Scenes &amp; Content</h2>
				<p>Included in this package are example scenes and pre-generated content to demonstrate some of the worlds that the framework can create and manage.
					These scenes can be found in the <a href="Experilous/Examples/Tile-Based Worlds/">&lt;project&gt;/Assets/Experilous/Examples/Tile-Based Worlds/</a> folder.
					The planar scenes each contain one planar topology, and can be controlled with standard arrow/WASD controls with mouse look; mouse wheel will adjust elevation.
					The spherical scene is similar, but without mouse look; instead, it uses a camera controller that locks the view onto the sphere.</p>
				<dl>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Jumble Go.unity">Jumble Go</a></dt>
					<dd>A basic implementation of Go, supporting square, hexagonal, and jumbled cells.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Spherical Path Finding Demo.unity">Spherical Path Finding Demo</a></dt>
					<dd>A generated tile-based planet with four different terrain types, unit path finding, and fog-of-war.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Texture Demo.unity">Texture Demo</a></dt>
					<dd>A demonstration of different techniques for generating UV mappings to apply textures to topology-based meshes.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Planar Topologies.unity">Planar Topologies</a></dt>
					<dd>A few pre-generated planar surfaces with various tile shapes.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Spherical Topology.unity">Spherical Topology.unity</a></dt>
					<dd>A pre-generated spherical surface with randomly shaped tiles which mostly began as hexagonal tiles before being randomized.</dd>
					<dt><a href="Experilous/Examples/Tile-Based Worlds/Tutorial 1.unity">Tutorial 1.unity</a></dt>
					<dd>The final scene after going through the <a href="https://www.youtube.com/watch?v=Gl9TaOvjKX4" target="_blank">Tutorial #1 video on YouTube</a>.</dd>
				</dl>
			</section>

			<section id="create-your-own">
				<h2 class="section-head">Creating Your Own Content</h2>
				<p>The content used in the above example scenes can be found in the <a href="Experilous/Examples/Tile-Based Worlds/Data">&lt;project&gt;/Assets/Experilous/Examples/Tile-Based Worlds/Data/</a> folder.
					Most of the data is not meant to be edited directly.  However, if you locate and select the asset within each subfolder named "Generator.asset", the inspector will show you the full details for generating the other assets in that subfolder.
					You can freely modify the values within the inspector and click the Generate button, and the associated scene should automatically use the new assets generated, in particular the prefab with all of the generated meshes.</p>
				<p>To create a generator from scratch, use the Create button in the Projects window, or right click in the Projects window content area where you would like to create the generator.
					Navigate in the menu to Topology, and then choose the type of topology you would like to create.  A folder will be created and a generator asset placed within it with some basic settings already configured.
					You should be able to immediately click the Generator button, or you can first adjust values.
					You will likely also want to add additional content generators, which you can do using the Add Generator button at the bottom of the inspector.
					The gear icon at the top right of every content generator provides a menu that will let you reorder or remove items.</p>
				<p>Once you've generated content, you can begin to use it from within your scene.
					Since most of the content is raw data wrapped in scriptable objects, you will be able to use very little of it unless you write your own components that can consume these objects.
					However, the generator is capable of creating prefabs which can easily be dragged into your scene just like any other prefab.</p>
				<p>Note that the prefab generator has a field where you can specify another prefab.
					This configurable prefab will be used by the prefab generator as a base template for any mesh renderers that it creates.
					You will want to assign a prefab that includes a mesh filter and mesh renderer component, with a material specified for the mesh renderer.
					Otherwise, the prefab will be rendered without any material at all, and will obviously not look correct as a result.
					There is a sample material included in the examples folder called "<a href="Experilous/Examples/Shared Resources/Manifold.mat">Manifold.mat</a>",
					and is used by "<a href="Experilous/Examples/Tile-Based Worlds/Resources/Manifold Mesh.prefab">Manifold Mesh.prefab</a>".
					You can assign this prefab to the prefab generator's mesh prefab field to get a quick idea of what the generated topology looks like.</p>
			</section>
		</section>
		
		<section class="chapter" id="topologies">
			<h2 class="section-head">Topologies, the Core Data Structure</h2>
			<p>The core of the Tile-Based Worlds framework is a topology, a data structure for representing the relations between vertices, edges, and faces.
				In terms of the primary use case for this framework, faces are typically synonymous with tiles, while vertices are the corners of each tile.
				Edges are the boundaries between two adjacent faces/tiles, though they can simultaneously be treated as the connections between two adjacent vertices/corners.</p>
			<p>Faces must have at least three neighbors, but have no practical upper bound.  (Technically, a cached neighbor count limits them to a maximum of 65,535 neighbors.)
				Vertices are similar, except that most algorithms permit a vertex with only two neighbors, and some might even be okay with a vertex with only a single neighbor.
				Each face and vertex can have a differing number of neighbors even within the same topology; a topology might consist of a mix of pentagons and hexagons, for example.
				Each edge has exactly two neighbors, one on each side of the edge.  Although technically, each edge is stored as a pair of half-edges, and each half-edge is directed, pointing at only one of the two neighbors.</p>
			<p>The class <code>Experilous.Topological.Topology</code> is responsible for storing all the raw data of the topology data structure.
				It also provides access to the elements of the data structure through nested structs <code>Vertex</code>, <code>Face</code>, <code>HalfEdge</code>, <code>VertexEdge</code>, and <code>FaceEdge</code>.
				The latter three structs all represent exactly the same underlying data, but also express the context within which edges are being used.
				Instances of <code>HalfEdge</code> refer to half-edges directly, while <code>VertexEdge</code> and <code>FaceEdge</code> refer to half-edges within the context of the vertex or face that they point <em>away from</em>.</p>
			<p>The <code>Vertex</code> and <code>Face</code> structs allow enumeration of their neighbors, in the form of <code>IEnumerator&lt;VertexEdge&gt;</code> and <code>IEnumerator&lt;FaceEdge&gt;</code>, respectively.
				These enumerators will visit the half-edges that radiate from the source vertex or border the source face in clockwise order.
				Given that <code>FaceEdge</code> provides <code>farFace</code> and <code>nextVertex</code> properties, and <code>VertexEdge</code> provides <code>farVertex</code> and <code>prevFace</code> properties,
				it is easy to enumerate all the neighboring vertices or faces of any given vertex or face.
				The <code>nearVertex</code> and <code>nearFace</code> properties can be used to get the implicit element whose neighors are being enumerated by a given <code>VertexEdge</code> or <code>FaceEdge</code>.</p>
			<p>The majority of faces in a topology will be ordinary "internal" faces, but depending on the shape of the topology, some faces might be external.
				This means that they're not part of the normal world, but are included in order to simplify the invariants of the data structure.
				In particular, the requirement that every edge has exactly two neighboring faces, and the requirement that the neighboring vertex count, edge count, and face count are all equal for any given vertex or face.
				An example topology would be a chess board, which has sixty-four internal faces, and then one external face which represents everything outside of the chess board.
				Another example would be the world map of the Civilization series of games, in which the north pole region and the south pole region are two distinct external faces.</p>
		</section>
		
		<section class="chapter" id="attributes">
			<h2 class="section-head">Element Attributes</h2>
			<p>The elements of a topology are stored in such a way that they all have contiguous integer indices starting from zero.
				This means that if you want to associate additional data with each element, all you need to do is create an array or list of the appropriate size and desired type,
				and this data can then be easily accessed whenever you want to look up that attribute's value for a given vertex, half-edge, or face.
				The most obvious attribute is probably vertex positions, which can be stored as a container of <code>Vector3</code>.
				Other examples include face normals, face colors, and edge pathfinding costs.</p>
			<p>Given that faces can be either internal or external, it can often be appropriate to store data only for internal faces.
				Therefore, all internal faces come first, starting at index zero, while all external faces are stored at the very end of the contiguous indices.
				For attributes that only make sense for internal faces, simply use the internal face count as the size when creating the container.
				For attributes that apply to all faces whether internal or not, use the total face count as the size.
				For attributes that only apply to external faces, you can create an appropriately sized container, but you'll need to index into it manually, since the indices of external faces don't start at zero.
			<p>The various helper structs discussed above all have an <code>index</code> property that can be used to access an array or list directly.
				Even better, however, is to create a wrapper around the container that implements the <code>IVertexAttribute</code>, <code>IEdgeAttribute</code>, or <code>IFaceAttribute</code> interface.
				This will allow the attributes to be accessed directly by one of the helper structs, without needing to access the <code>index</code> property explicitly.
				Additionally, this can provide further utility by allowing the access of an attribute to be modified based on the context of access.
				This is particularly useful in the case of wrap-around edges discussed below, in which a vertex's effective position is dependent upon which neighbor (face or vertex) defines the current context.</p>
		</section>
		
		<section class="chapter" id="edge-wrapping">
			<h2 class="section-head">Edge Wrapping</h2>
			<p>For a topological world that allows wrapping around along some or all world boundaries, complications can arise when the topology is embedded within standard Euclidean space.
				Consider a flat rectangular world that wraps around along the right and left sides (such as a map from the Civilization series).
				The vertices along the left edge are in fact the same vertices along the right edge, and so each one will only have a single position in space, which I will dub the "canonical" position.
				But when drawing the tiles on the left side of the map versus those on the right, the vertex positions need to be treated differently.
				If the canonical positions are the ones that apply to the left side of the map, then when using those vertex positions along the right side of the map,
				the full width of the world needs to be added to the canonical positions to get the effective positions for rendering the tiles.</p>
			<p>To enable this kind of transformation, one needs to know the context of how an attribute such as position is being accessed.
				This context is defined in terms of which other topology object the attribute is relative to.
				In the above example, vertex positions are being accessed relative to the face that is being rendered, so it is a vertex-to-face relation.
				If we know the wrapping relation between any particular face and a neighboring vertex, then we can decide how to transform the canonical position to get the final position to be used.</p>
			<p>Within the Tile-Based Worlds framework, this relational information is stored within the edge data,
				encoding details about the near vertex and face and far vertex and face all relate to each other and to the edge itself.
				Edges can be used to access vertex and face attributes, and so such attributes can use the relational information to transform the vertex or face attribute value based on wrapping behavior.
				For example, accessing a vertex position using a face edge will enable the attribute container to return the vertex position relative to the near face of the edge used for access.</p>
			<p>Most attributes are oblivious to wrapping, and most attributes would not be able to meaningfully utilize wrapping information anyway.
				To take advantage of wrapping behavior, either use the <code>PositionalVertexAttribute</code>, <code>PositionalEdgeAttribute</code>, and <code>PositionalFaceAttribute</code> classes to store your data,
				or create similar classes of your own that make use of an edge's relational information when accessing the attribute using an edge.</p>
		</section>
		
		<section class="chapter" id="surface-types">
			<h2 class="section-head">Surface &amp; Topology Types</h2>
			<p>Surfaces are useful abstractions for describing the overall shape that a topology will represent, without directly storing the all the vertex/edge/face data explicitly.
				They provide a convenient description from which the full topology data can be generated.
				They can also provide additional details beyond the raw topology data that aids other areas of code in performing their functions.</p>
			
			<section id="spherical-surfaces">
				<h3 class="section-head">Spherical Surfaces</h3>
				<p>Spherical surfaces are useful for creating tile-based planets.
					Because of the nature of the sphere, there are very few perfectly regular tilings, so you'll almost inevitably require a mix of vertices and/or faces with differing numbers of neighbors.</p>
				<p>The current methods for generating topologies from spherical surfaces come from the <code>SphericalManifoldUtility</code>,
					and begin with one of the five Platonic solids which can then be further subdivided as desired.
					If you wish to predictability of the occasional vertex or face with a different number of neighbors than most that result from subdividing a Platonic solid,
					see the section on <a href="#randomization">topology randomization</a>.</p>
			</section>
			
			<section id="planar-surfaces">
				<h3 class="section-head">Planar Surfaces</h3>
				<p>Planar surfaces are the most prevalent form of tile-based surfaces.
					While they can be extended to support elevations and therefore do not need to be strictly flat, they still must remain completely mappable to a two-dimensional plane.
					Because of their planar nature, perfectly regular tilings are far more flexible than with spherical surfaces,
					but <a href="#randomization">topology randomization</a> can be applied to either surface type equally.
				
				<section id="quad-grid-tiles">
					<h4 class="section-head">Quad Grid Tiles</h4>
					<p>To aid in creating and using standard grids of squares (or parallelograms in general), you may use the <code>RectangularQuadGrid</code> class.
						It is rectangular in that the overall world it describes has a specified width and height (measured in face counts in each dimension).
						It is a quad grid in that each face has exactly four neighbors (or eight, if you also count the four diagonal faces that only touch at a vertex).
						The faces do not need to be squares, but can be any sort of parallelogram.</p>
					<p>Because <code>RectangularQuadGrid</code> implements the <code>IFaceNeighborIndexer</code> interface,
						it can be used by the <code>TopologyUtility.BuildTopology()</code> function to automatically create the full topology data.
						Alternatively, you can use <code>RectangularQuadGrid.CreateManifold()</code> to not only create the topology data,
						but also provide vertex positions according to the specifications of the surface.</p>
					<p>Also, by implementing the <code>IFaceIndexer2D</code> and <code>IVertexIndexer2D</code> interfaces,
						<code>RectangularQuadGrid</code> can be used to get the two-dimensional integer coordinate of each vertex and face,
						or to perform the inverse operation, find the vertex or face given a two-dimensional integer coordinate.
						This makes it easy to implement any algorithms that are most naturally expressed using such a two-dimensional coordinate system.</p>
				</section>
				
				<section id="hex-grid-tiles">
					<h4 class="section-head">Hex Grid Tiles</h4>
					<p>To aid in creating and using standard grids of hexagons, you may use the <code>RectangularHexGrid</code> class.
						Like the <code>RectangularQuadGrid</code> class, it is rectangular in that the overall world it describes has a specified width and height (measured in face counts in each dimension).
						It is a quad grid in that each face has exactly four neighbors (or eight, if you also count the four diagonal faces that only touch at a vertex).
						Its faces, however, are all hexagons, as its name implies.</p>
					<p>Constructing a hex grid requires a bit more information than constructing a quad grid.
						There are a few options regarding how to arrange the rows and columns of the grid.
						The primary option is which, if either, of the two axes will have its hexagons staggered back and forth every other row/column.
						If staggered, then you can acquire a roughly rectangular world while still maintaining regular hexagonal faces.
						Otherwise, the hexagonal faces will either need to be distorted, or your overall world shape will instead be a parallelogram, with default interior angles of 60&deg; and 120&deg;.
					<p>Secondary options are whether the angle produced by the three hexagons at the origin is acute or obtuse,
						and whether staggered rows/columns have one fewer face in order to maintain symmetry.</p>
					<p>Because <code>RectangularHexGrid</code> implements the <code>IFaceNeighborIndexer</code> interface,
						it can be used by the <code>TopologyUtility.BuildTopology()</code> function to automatically create the full topology data.
						Alternatively, you can use <code>RectangularHexGrid.CreateManifold()</code> to not only create the topology data,
						but also provide vertex positions according to the specifications of the surface.</p>
					<p>Also, by implementing the <code>IFaceIndexer2D</code> and <code>IVertexIndexer2D</code> interfaces,
						<code>RectangularHexGrid</code> can be used to get the two-dimensional integer coordinate of each vertex and face,
						or to perform the inverse operation, find the vertex or face given a two-dimensional integer coordinate.
						This makes it easy to implement any algorithms that are most naturally expressed using such a two-dimensional coordinate system.
						Note that because hex grids are more complex than square grids, the exact behavior of the two-dimensional coordinates depends on how the grid was constructed.
						Alternative implementations of <code>IFaceIndexer2D</code> and <code>IVertexIndexer2D</code> can be written to provide alternate indexing schemes if desired.</p>
				</section>
			</section>
		</section>
		
		<section class="chapter" id="additional">
			<h2 class="section-head">Additional Utilities</h2>
			<section id="dynamic-mesh">
				<h3 class="section-head">Dynamic Mesh</h3>
				<p>The <code>DynamicMesh</code> class is responsible for building one or more <code>Mesh</code> objects for a topology,
					as well as easing the process of updating that mesh as various attributes of the topology change.
					It does this by triangulating topology faces according to a custom triangulation method provided it,
					and maintaining arrays of all relevant mesh data for easy and efficient updates.</p>
				<p>Meshes can utilize a variety of different vertex attributes, depending on what is needed by the shader in use.
					Therefore, the dynamic mesh is capable of accepting any combination of vertex attributes, and can acquire their values in any way desired.
					This is achieved through the generalized <code>ITriangulation</code> interface,
					as well as standard implementations of that interface which expose vertex attribute retrieval through custom delegates.</p>
				<p>The three supplied triangulation methods are strip, fan, and umbrella triangulation.
					The strip method will order the vertices and vertex indices of each face in such a way as to follow the conventional triangle strip pattern,
					and the fan does likewise for its respective common pattern.
					Note, however, that this does not mean that the GPU will be sent draw calls to render faces as actual triangle strips or fans,
					only that the triangle vertices will be ordered in this fashion.</p>
				<p>The umbrella pattern is similar to the fan, except that instead of starting at an arbitrary outer vertex and creating a fan from the remaining outer vertices,
					it requires a center vertex also, and then builds a fan around all the outer vertices.
					Additionally, the first and last triangles of this fan share the first vertex with each other, whereas a fan would require a duplicate.</p>
				<p>All of these methods also support subdividing the face into concentric rings, specified by ring depth which defaults to 1.
					Therefore, not only will the triangulation need values for the outer vertices (and the center vertex for the umbrella pattern),
					vertex attribute values will also be needed for the inner vertices.
					The delegates consumed by these triangulation classes will therefore expect the same number of vertex values to be supplied during each call as there are concentric rings,
					setting the outermost rings first, moving inward to the innermost rings last.</p>
				<p>Once a dynamic mesh has been constructed, the actual <code>Mesh</code> instances are accessible through the <code>submeshCount</code> property and the <code>GetSubmesh()</code> method,
					or through the <code>submeshes</code> enumerable property.
					(Note that "submesh" in this context is distinct from the submesh concept of Unity's <code>Mesh</code> class,
					and refers to entirely separate <code>Mesh</code> instances, each with their own subset of vertices.)
				<p>If changes need to occur to any particular vertex attribute or to any particular area of the mesh, <code>RebuildFace()</code> can be used to update a face's mesh data.
					It must be given the same type of triangulation that was used to originally construct the mesh,
					but the details of how the vertex attribute values are assigned can differ.
					In particular, not all attributes need to be set; values that stay the same can be completely skipped.
					For example, perhaps only the vertex colors need to be updated, or the UV values; positions and normals can be left as they are in this case.
				<p>Rebuilding a face only updates the main memory representation of the mesh data.
					Once all faces have been rebuilt with new data, call <code>RebuildMesh()</code> to finalize the changes and apply them to the actual <code>Mesh</code> instances.
					You can specify which vertex attributes are to be considered dirty.
					Only these arrays will be updated, and only for submeshes marked dirty through the process of rebuilding a face within a submesh.
					This makes dynamic mesh updates more efficient than a brute-force rebuilding of all the data from scratch.</p>
				<p>The triangle indices themselves cannot be altered once constructed, so do not attempt to alter the overall topological structure
					(such as through randomization or pivoting/spinning individual edges).
					If you do so, you will need to create a new dynamic mesh from scratch rather than reusing the current one and all of its submeshes.</p>
			</section>
			
			<section id="randomization">
				<h3 class="section-head">Topology Randomization</h3>
				<p>The <code>TopologyRandomizer</code> class can be used to jumble a topology to be less regular.
					It achieves this by altering a random subset of edges, shifting the edges to different pairs of nearby vertices or faces than they had been relating originally.</p>
				<p>It performs this process in one or more passes.  After each pass through all edges, some relaxation and repair passes are performed to fix up any positional anomalies produced in the main pass.
					These anomalies are due to the fact that the main pass alters the topological relations only, and does not adjust vertex positions or any other attributes at all.
					Faces are likely to become concave or even inside out during the main pass.</p>
				<p>The relaxation passes attempt to gently nudge vertex positions around in order to conform to certain constraints.
					The two constraints currently implemented aim for regularity and equal per-face area, respectively.
					Regularity refers to polygon regularity.  This constraint prefers that all edge lengths be equal,
					but it strongly biases faces with more neighbors to be significantly larger than faces with fewer neighbors.
					The equal area constraint on the other hand prefers all faces to have roughly equal area,
					but it tends to produce irregular polygon faces and edges of varying lengths.
					There are examples of blending these two constraints together using any proportion desired.</p>
				<p>The repair pass is more of a blunt process to correct for any egregious errors produced in the main pass and not fixed by relaxation,
					as well as such errors that are actually produced by the relaxation pass.
					These are errors of concavity or more serious flaw in the shape of a face.</p>
			</section>
			
			<section id="spatial-partitioning">
				<h3 class="section-head">Spatial Partitioning</h3>
				<p>Spatial partitioning is a means of dividing up space in such a way that certain types of spatial lookups can be performed efficiently.
					For topologies, a common operation is to determine which face a particular ray intersects, if any.
					Implementations of the <code>IFaceSpatialPartitioning</code> interface provide this functionality.</p>
				<p>This framework comes with the <code>UniversalFaceSpatialPartioning</code> class, a universal implementation that works with any topology.
					Whether you are working with a sphere or a plane, with square grids, hexagonal grids, or randomized tiles,
					this class will be able to tell you which face any specified ray intersects.
					It will even work with wrap-around worlds, when the ray is aimed at a region outside of the canonical world bounds.</p>
				<p>If you have a highly regular grid and need to perform a large number of ray intersections,
					it may be preferable to implement a more intelligent and efficient intersection test using knowledge of the grids irregularity.</p>
			</section>
			
			<section id="topology-traversal">
				<h3 class="section-head">Topology Traversal</h3>
				<section id="path-finding">
					<h4 class="section-head">Path Finding</h4>
					<p>Depending on your usage of topologies generated by this framework,
						it is likely that at some point you'll need to find paths from one face to another.
						The <code>PathFinder</code> class enables you to find such paths flexibly and efficiently, using the A* algorithm.</p>
					<p>The heuristic cost function and actual cost can both be defined according to your particular pathfinding needs,
						and defaults are provided for using standard Euclidean distance or spherical distance derived from face positions.</p>
					<p>Instances of <code>PathFinder</code> as well as instances of the path classes it returns are fully reusable,
						which can cut down on the amount of memory management that the runtime needs to perform.
						Nonetheless, multiple independent instances of <code>PathFinder</code> can also be created,
						allowing fully concurrent processing on multiple threads without conflict.</p>
				</section>
				
				<section id="connected-visitation">
					<h4 class="section-head">Connected Visitation</h4>
					<p>If you wish to enumerate connected vertices or faces, you can make use of the various static methods of the <code>VertexVisitationUtility</code> and <code>FaceVisitationUtility</code> classes.
						All methods have similar interfaces to support single or multiple starting elements, and a flexible selection of visitation delegates depending on the needs of each particular visitation.</p>
					<p>The simplest delegate type provides only the vertex or face being visited.
						All other information tracked by the visitation algorithm remains unexposed, and no additional control over how the algorithm proceeds or terminates is offered.
					<p>A step up from there, a delegate can instead be provided with an edge instead of a vertex or face,
						thus providing access to information about not only which vertex or face is currently being visited, but also which vertex or face it is coming from.</p>
					<p>Some types of visitation can optionally provide additional information about the visitation.
						Depth-ordered visitation can supply the current depth of visitation (the number of edges traversed from the root vertex or face).
						Distance-ordered visitation can supply the cumulative distance from the root vertex or face;
						the depth can also be provided in addition to or even instead of the distance, though distance will still determine the order of visitation.</p>
					<p>Finally, all variants of delegate interface also support an optional out parameter to control the operation of the algorithm.
						By default, this state parameter will be set to <code>Continue</code>, meaning that all connected unvisited neighbors of the current vertex or face will be added to the queue to visit shortly.
						By setting this state to <code>Discontinue</code>, this vertex or face will still be marked as visited, but no further neighbors will be visited from this particular vertex or face.
						(This does not prevent them from being visited through other neighbors, however.)
						By setting this state to <code>Ignore</code>, it is as if the vertex or face were not yet visited at all, and a visitation may be attempted again, but from another neighbor through a different edge.
						And lastly, by setting this state to <code>Stop</code>, the entire algorithm will terminate.
						This is commonly useful when using the visitation methods as a search tool, looking for at least one connected vertex or face that fits a given criterion.
						Once such an element is found, there's no point in continuing further.</p>
					<p>The order of visitation is determined by the particular method group chosen, and come in four major types.
						The <code>AnyOrder</code> type only concerns itself with visiting all connected elements with no focus on order.  This is ideal for many existence-based searches.
						The <code>ByDepth</code> type orders visitation according to the number of edges traversed from root elements.
						This can be done in breadth-first order (prioritizing small depths over large) or depth-first (large depths prioritized over small).
						The <code>ByDistance</code> type is similar, but can use numerical edge attributes, or Euclidean or spherical positional attributes to order elements by cumulative distance from the root elements.
						These similarly come in breadth-first and depth-first variants.
						And the fourth is <code>RandomOrder</code> type, similar to the first, but guaranteeing an unbiased random order,
						rather than an unspecified order that is likely to be mechanically biased by how elements are pushed onto and popped from the underlying queue.
						This can be particularly convenient for dividing a topology into a collection of randomly shaped clusters.</p>
				</section>
			</section>
		</section>

		<section class="chapter" id="generation">
			<h2 class="section-head">In-Editor Generation</h2>
			<p>The Tile-Based Worlds framework has been designed first and foremost as a collection of run-time utilities, to allow building and interacting with topologies through user scripts.
				But sometimes these topologies can be fully created beforehand, and so editor integration has been included to assist in these cases.</p>
			<p>Use of these editor interfaces is done through the inspector of the <code>GeneratorExecutive</code> objects.
				These can be created through the <code>Assets/Create/Topology</code> menu, and will be populated with a default set of data and object generators.
				The interface closely mimics the standard inspector interface, with each generator presented similarly to how components are presented on a game object.
				But generators also strongly follow a node-based model, where generators may have a variety of inputs and outputs and connect up to each other as needed.</p>
			<p>Once all desired generators have been added and configured, the Generate button at the top of the inspector can be pressed to run all generators.
				Depending on how each output is configured and consumed, some outputs will be saved as assets within the same folder as the root generator asset, or under subfolders.
				Common assets such as meshes and prefabs can be used directly in scenes as normal, and will be updated in place if the data is regenerated with different settings.
				Custom data (classes deriving from <code>ScriptableObject</code>) can be used within user scripts, or referenced by custom components that understand the particular data type.</p>
			<p>By default, each generator's outputs are collapsed in the inspector.
				Expanding will show an abbreviated list of outputs, with their names, data types, and a toggle to enable or disable them.
				Each output can be further expanded, permitting the adjustment of its name, path (subfolder where it is saved), and more details on its type (mouseover to get a fully namespaced tooltip).
				Additionally, its availability can be edited.
				"Available During Generation" means that other generators can use this output as incoming data, but it won't be saved as a distinct asset file for use later on.
				"Available After Generation" will hide the output when hooking up the inputs of other generators, but will still be saved as an asset file.
				"Available Always" naturally combines the two.
				Unchecking the "Enabled" toggle will essentially mark it as "Never Available", neither usable by other generator nor saved as an asset.</p>
			<p>Each collection of generators tracks which assets where generated by its own generators, and will cleanup leftover assets when configurations change and regeneration creates fewer or a different set of outputs.
				If for some reason you want to detach generated assets and use them in their current form independently from the generator,
				you can click the "Detach Assets" button near the top of the inspector, and then move the assets to a location where they won't get overwritten by another generation pass.</p>
			<p>Moving a collection of generators is as easy as moving or renaming the folder.
				Alternatively, you should be able to move just the "Generator" asset and then regenerate the assets, and everything ought to be moved into the same folder as that asset.</p>
			<p>If you would like to copy a collection of generators so that you can modify and generate similar but altered assets,
				you can alt-drag the "Generator" asset to copy it to a different folder.
				This copy will know to drop all associations with existing generated assets, and will therefore create entirely new assets when the Generate button is pressed, leaving the original assets untouched.</p>
			<p>If the provided generators are not sufficient, additional custom generators can be created
				using those in the <a href="Plugins/Editor/Experilous/Topological">Plugins/Editor/Experilous/Topological/</a> folder as a model.</p>
		</section>
	</body>
</html>
